# 多线程[^1]
[^1]: 一共有四种创建方式

## 线程：
即程序的一条执行路径，多线程即一个程序拥有多条执行路径  
在JVM中，每一个线程都有各自的一套虚拟机栈和程序计数器，而所有的进程都共享一套方法区和堆（一个进程中可以有多个线程）
### 单核与多核CPU：
单核CPU的多线程实际上为假的多线程，在一个时间单元中该核也最多只能执行一个线程，有多个线程只能等待被处理。但是由于CPU处理速度快，也就造就了同时多线程的假象。  
多核CPU才能执行真正的多线程。一个Java应用程序java.exe至少有三个线程：main()主线程、gc()垃圾回收线程、异常处理线程。
### 并行与并发：
#### 并行：
多个CPU同时执行多个任务（多个人同时做不同事）
#### 并发：
一个CPU（采用时间片）同时执行多个任务

## Java多线程的创建：
### 定义Thread类[^2]的子类：
[^2]: Thread类（java.lang.Thread），Java的多线程都必须通过该类来实现
该种方式分为四个步骤：
- 新创建一个子类，继承Thread类
- 子类中重写Thread中的run()
- 在执行类中创建子类实例对象
- 实例对象调用start()
#### 注意：
重写的run()的方法体中应为你需要执行的操作（例如遍历100以内的偶数） 
start()执行了两个操作：  
1、创建当前线程  
2、调用run()  
如果没有使用start()而是直接调用run()，那么程序仍然会执行，但是不会新增线程，从始到终就只有main()线程，依照顺序执行  
执行类中main()方法体内，在子类调用start()之前（也包括子类实例调用start()这一行为）都由main()主线程执行，start()后JVM增加一个新的线程来执行run()中的方法体，与main()线程互相独立，谁先执行的先后完全看两条线程各自的性能。  
这也意味着main()中start()后的代码运行结果，可能出现在start()结果前，也可能出现在start()后，或者呈现交叉  
同一个类实例不能调用start()两次（详见start()的源码），要想重复使用，可以新建一个相同类的对象，继续调用start()
961