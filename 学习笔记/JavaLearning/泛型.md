# 泛型：

  有人认为存储数据类型单一是数组的缺点，但实际上单一的数据类型拥有更多的共同属性，方便处理和操作；相反，数据类型不单一反而会使得处理数据的难度大大增加。在JDK1.5之前，只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的。  
  泛型是不能使用**基本数据类型的**，只能使用它们的包装类。  
  带有泛型的类或接口实例化时，如果没有指明泛型的具体类型，则**默认为Object**。  
  子类继承带泛型的父类或者实现泛型接口时，**要么**继续继承父类的泛型，在后续定义变量、声明方法时使用泛型，**要么**直接在继承或实现时直接指明继承父类的某个特定类型，那么此时的子类就不再是泛型，在被调用时不需要去指明泛型的类型。

## 作用：
1. 编译时，会进行类型检查，保证数据的安全
2. 避免了强转操作（有时强转会出错）
3. 能够节省部分代码（比如Comparable接口也是泛型，那么后续就不用强转）

## 自定义泛型结构：

泛型类、泛型接口、泛型方法
//567

## 注意事项：

1. 静态方法不能使用泛型

2. 不能直接创建泛型类的数组（如果能够创建泛型类的数组，那也就意味着可以往数组中添加任意类型，这也违背了泛型创建的初衷）。如果想使用泛型类数组，先创建一个Object类数组，然后使用强转。E [] elements = (E[])new Object[capacity];。

	- 想要创建指定泛型的数组也可以使用如下方法：

		Stream.toArray(Person::new);

3. 异常类不能是泛型（catch的时候会有问题）

## 通配符（?）：

1. List<?> 是 List<String> 、 List<Object> 等各种泛型 List 的父类。
2. 读取List<?>的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object 。
3. 写入 list 中的元素时，不行。因为我们不知道 c 的元素类型，我们不能向其中添加对象。
	唯一的**例外**是 null ，它是所有类型的成员。
4. 通配符不能作为方法的返回值
5. 通配符不能用作泛型类的声明
6. 通配符不能创建对象（即不能与new搭配）